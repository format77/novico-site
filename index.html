<!doctype html>
<html lang="fi" class="no-js">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>YRITYS OY</title>
  <meta name="robots" content="noindex,nofollow,noarchive">
  <style>
    :root {
      --dark: #0B0C0E;   /* tausta tummassa */
      --light: #F5F5F0;  /* teksti tummassa */
      --gap: clamp(20px, 5vw, 64px);
      --text-max: 640px;
    }
    [data-theme="light"] { --dark: #F5F5F0; --light: #0B0C0E; } /* käännetyt värit */

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    html { color-scheme: light dark; }
    body {
      margin: 0;
      background: var(--dark);
      color: var(--light);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.6;
    }
    .wrap {
      min-height: 100dvh;
      display: grid;
      grid-template-columns: 1fr 1.3fr; /* vasen teksti, oikea verkko */
      gap: var(--gap);
      align-items: center;
      padding: clamp(24px, 6vw, 80px);
    }
    @media (max-width: 900px) {
      .wrap { grid-template-columns: 1fr; }
    }

    /* Vasen sarake (teksti) */
    .text {
      max-width: var(--text-max);
      z-index: 1;
    }
    h1 {
      margin: 0 0 .25em 0;
      font-weight: 500;              /* ohut/moderni ilme järjestelmäfontilla */
      letter-spacing: .5px;
      font-size: clamp(40px, 8vw, 96px);
      line-height: 1.05;
    }
    .meta {
      margin-top: 12px;
      font-size: clamp(16px, 1.6vw, 20px);
    }
    .meta p { margin: .3em 0; }

    /* Oikea sarake (konstellaatio) */
    .field {
      position: relative;
      min-height: 60dvh;
    }
    canvas.network {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      /* hiiri läpäisee kanvaksen, jotta sivu on helppo käyttää */
      pointer-events: none;
    }

    /* Teemavalitsin yläoikealla */
    .theme {
      position: fixed;
      top: 14px; right: 14px;
      display: flex; gap: 10px;
      z-index: 2;
    }
    .dot {
      width: 24px; height: 24px; border-radius: 50%;
      border: 2px solid var(--light); background: var(--dark);
      display: inline-flex; align-items: center; justify-content: center;
      cursor: pointer; outline: none;
    }
    .dot[aria-pressed="true"] { box-shadow: 0 0 0 2px var(--light) inset; }
    .dot.light { border-color: var(--dark); background: var(--light); }
    .dot.light[aria-pressed="true"] { box-shadow: 0 0 0 2px var(--dark) inset; }
    .visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,1px,1px); white-space: nowrap; border: 0; }
    .skip { position:absolute; left:-9999px; top:auto; }
    .skip:focus { position:fixed; left:12px; top:12px; padding:.5rem .75rem; background:var(--light); color:var(--dark); }
    @media (prefers-reduced-motion: reduce) {
      .field { min-height: 40dvh; }
    }
  </style>
  <script>document.documentElement.classList.remove('no-js');</script>
</head>
<body>
  <a class="skip" href="#sisalto">Siirry sisältöön</a>

  <!-- Teemavalitsin: tumma ja vaalea ympyrä -->
  <div class="theme" role="group" aria-label="Vaihda teema">
    <button id="darkBtn" class="dot dark" aria-pressed="true" aria-label="Tumma teema"></button>
    <button id="lightBtn" class="dot light" aria-pressed="false" aria-label="Vaalea teema"></button>
  </div>

  <main id="sisalto" class="wrap">
    <section class="text" aria-label="Yrityksen tiedot">
      <h1>YRITYS OY</h1>
      <div class="meta" aria-label="Yhteys- ja laskutustiedot">
        <p>Esimerkkikatu 1, 00100 Helsinki</p>
        <p><a href="mailto:info@yritys.fi" style="color:inherit; text-decoration: underline;">info@yritys.fi</a></p>
        <p>Y-tunnus 1234567-8</p>
      </div>
    </section>

    <section class="field" aria-hidden="true">
      <canvas class="network" id="net"></canvas>
    </section>
  </main>

  <script>
    (function () {
      // ---------- Teema ----------
      const root = document.documentElement;
      const darkBtn = document.getElementById('darkBtn');
      const lightBtn = document.getElementById('lightBtn');
      const key = 'theme-pref'; // 'dark' | 'light'

      function setTheme(t) {
        if (t === 'light') {
          root.setAttribute('data-theme', 'light');
          darkBtn.setAttribute('aria-pressed', 'false');
          lightBtn.setAttribute('aria-pressed', 'true');
        } else {
          root.setAttribute('data-theme', 'dark');
          darkBtn.setAttribute('aria-pressed', 'true');
          lightBtn.setAttribute('aria-pressed', 'false');
        }
      }
      const saved = localStorage.getItem(key);
      setTheme(saved || 'dark');
      darkBtn.addEventListener('click', () => { localStorage.setItem(key, 'dark'); setTheme('dark'); recolor(); });
      lightBtn.addEventListener('click', () => { localStorage.setItem(key, 'light'); setTheme('light'); recolor(); });

      // ---------- Konstellaatio (2D-canvas) ----------
      const canvas = document.getElementById('net');
      const ctx = canvas.getContext('2d');
      const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      let width, height, dpr, nodes = [], mouse = {x: -9999, y: -9999};
      let anim, running = false;

      function size() {
        const r = canvas.getBoundingClientRect();
        dpr = Math.max(window.devicePixelRatio || 1, 1);
        width = Math.floor(r.width * dpr);
        height = Math.floor(r.height * dpr);
        canvas.width = width;
        canvas.height = height;
      }

      function color() {
        // käytetään vain kahta väriä
        const styles = getComputedStyle(document.documentElement);
        return {
          bg: styles.getPropertyValue('--dark').trim(),
          fg: styles.getPropertyValue('--light').trim()
        };
      }

      function createNodes() {
        nodes = [];
        const area = (width * height) / (dpr * dpr);
        const target = Math.min(400, Math.max(160, Math.floor(area / 32000))); // skaalautuva määrä
        for (let i = 0; i < target; i++) {
          nodes.push({
            x: Math.random() * width,
            y: Math.random() * height,
            vx: (Math.random() - 0.5) * 0.08 * dpr,
            vy: (Math.random() - 0.5) * 0.08 * dpr
          });
        }
      }

      function step() {
        const { fg, bg } = color();
        ctx.clearRect(0, 0, width, height);
        // tausta on läpinäkyvä: canvas päästää sivun taustan läpi
        const maxDist = Math.min(width, height) * 0.12;
        const mouseR = Math.min(width, height) * 0.09;

        // liike
        for (const n of nodes) {
          n.x += n.vx; n.y += n.vy;
          // perus kohina: kevyt reunapomppu
          if (n.x < 0 || n.x > width) n.vx *= -1;
          if (n.y < 0 || n.y > height) n.vy *= -1;
        }

        // yhteydet
        ctx.lineWidth = Math.max(0.5, 0.75 * dpr / 2);
        for (let i = 0; i < nodes.length; i++) {
          const a = nodes[i];
          // piste
          const dxm = a.x - mouse.x, dym = a.y - mouse.y;
          const md2 = dxm*dxm + dym*dym;
          const nearMouse = md2 < mouseR * mouseR;

          // pisteen piirto
          ctx.beginPath();
          ctx.fillStyle = fg;
          const r = nearMouse ? 2 * dpr : 1 * dpr;
          ctx.arc(a.x, a.y, r, 0, Math.PI * 2);
          ctx.fill();

          // viivat lähellä
          for (let j = i + 1; j < nodes.length; j++) {
            const b = nodes[j];
            const dx = a.x - b.x, dy = a.y - b.y;
            const d2 = dx*dx + dy*dy;
            if (d2 < maxDist * maxDist) {
              // läpinäkyvyys etäisyyden ja hiiren läheisyyden mukaan
              const alpha = 0.12 * (1 - (d2**0.5 / maxDist)) + (nearMouse ? 0.08 : 0);
              ctx.strokeStyle = fg;
              ctx.globalAlpha = Math.min(0.25, Math.max(0.04, alpha));
              ctx.beginPath();
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(b.x, b.y);
              ctx.stroke();
              ctx.globalAlpha = 1;
            }
          }
        }
        anim = running && requestAnimationFrame(step);
      }

      function start() {
        if (running) return;
        running = true; anim = requestAnimationFrame(step);
      }
      function stop() {
        running = false; if (anim) cancelAnimationFrame(anim);
      }
      function recolor() {
        // piirtovärit päivittyvät getComputedStyle:stä jokaisella framella,
        // joten riittää uusi askeleen käynnistys
        if (!reduceMotion) { stop(); start(); } else { drawStatic(); }
      }

      function drawStatic() {
        stop();
        const { fg } = color();
        ctx.clearRect(0, 0, width, height);
        const maxDist = Math.min(width, height) * 0.12;
        ctx.lineWidth = Math.max(0.5, 0.75 * dpr / 2);
        for (let i = 0; i < nodes.length; i++) {
          const a = nodes[i];
          ctx.beginPath(); ctx.fillStyle = fg;
          ctx.arc(a.x, a.y, 1 * dpr, 0, Math.PI * 2); ctx.fill();
          for (let j = i + 1; j < nodes.length; j++) {
            const b = nodes[j];
            const dx = a.x - b.x, dy = a.y - b.y, d = Math.hypot(dx, dy);
            if (d < maxDist) {
              const alpha = 0.12 * (1 - d / maxDist);
              ctx.strokeStyle = fg; ctx.globalAlpha = Math.min(0.25, Math.max(0.04, alpha));
              ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke(); ctx.globalAlpha = 1;
            }
          }
        }
      }

      // koko
      function init() { size(); createNodes(); reduceMotion ? drawStatic() : start(); }
      init();
      window.addEventListener('resize', () => { size(); createNodes(); recolor(); });

      // Hiiren vaikutus (vain näkyvä välilehti)
      const field = canvas.parentElement;
      field.addEventListener('mousemove', (e) => {
        const r = field.getBoundingClientRect();
        mouse.x = (e.clientX - r.left) * dpr;
        mouse.y = (e.clientY - r.top) * dpr;
      });
      field.addEventListener('mouseleave', () => { mouse.x = mouse.y = -9999; });

      // Pysäytä kun välilehti piilossa
      document.addEventListener('visibilitychange', () => {
        if (document.hidden || reduceMotion) stop(); else start();
      });
    })();
  </script>
</body>
</html>

